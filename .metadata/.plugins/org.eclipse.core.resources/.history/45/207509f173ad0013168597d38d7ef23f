package com.jbentley.spotmapper;

import com.google.android.gms.location.LocationListener;
import com.google.android.gms.maps.CameraUpdateFactory;
import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.GoogleMap.OnMyLocationChangeListener;
import com.google.android.gms.maps.GoogleMapOptions;
import com.google.android.gms.maps.MapFragment;
import com.google.android.gms.maps.MapView;
import com.google.android.gms.maps.model.CameraPosition;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.Marker;
import com.google.android.gms.maps.model.MarkerOptions;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.location.Location;
import android.location.LocationManager;
import android.os.Bundle;
import android.util.Log;

public class SavedSpotNavigation extends Activity implements android.location.LocationListener, SensorEventListener{
	MapView mapS;
	private GoogleMap mMapS;
	private LocationManager locationManagerS;
	private LatLng mySavedLoc;
	private Location myCurrentLocation;
	private LatLng myCurrentLatLng;
	private String nameLoc;
	private String latLoc;
	private String longLoc;
	private Boolean geoFenceLoc;
	private String timeLoc;
	private SensorManager sensorMngr;
	
	Sensor accelormtr;
	Sensor magnomtr;
	private float bearingFlt;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_saved_spot_navigation);

		locationManagerS = (LocationManager) this.getSystemService(Context.LOCATION_SERVICE);

		locationManagerS.requestLocationUpdates(LocationManager.GPS_PROVIDER,  3000 /*5 seconds*/  , 0, this);
		
		sensorMngr = (SensorManager) getSystemService(SENSOR_SERVICE);
		accelormtr = sensorMngr.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
		magnomtr = sensorMngr.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);
		
		if(sensorMngr !=null){
			sensorMngr.registerListener(this, accelormtr, SensorManager.SENSOR_DELAY_UI);
			sensorMngr.registerListener(this, magnomtr, SensorManager.SENSOR_DELAY_UI);
		}
		
		


		//get extras passed from MainNavActivity
		Bundle extras = getIntent().getExtras();
		nameLoc = extras.getString("nameSavedLoc");
		latLoc = extras.getString("latSavedLoc");
		longLoc = extras.getString("longSavedLoc");
		geoFenceLoc = extras.getBoolean("geoFenceSavedLoc");
		timeLoc = extras.getString("timeSavedLoc");

		//convert lat and long strings to long for use with LatLng

		Double latFromString;
		Double longFromString; 

		latFromString = Double.valueOf(latLoc);
		longFromString = Double.valueOf(longLoc);

		//passed location coordinates
		mySavedLoc = new LatLng(latFromString, longFromString);


		Log.i("EXTRAS", extras.toString());

		//Dispaly a snippet on a pin if loc is tagged for geo
		String geoDisplay;

		if (geoFenceLoc){
			geoDisplay = "Tagged for Geofence";
		} else {
			geoDisplay = "Not tagged for Geofence";
		}






		//get the map fragment 
		mMapS = ((MapFragment) getFragmentManager().findFragmentById(R.id.map)).getMap();
		if (mMapS != null) {

			//enable my location
			mMapS.setMyLocationEnabled(true);

			//google map options
			GoogleMapOptions mapOptions = new GoogleMapOptions();
			mapOptions.mapType(GoogleMap.MAP_TYPE_NORMAL)
			.compassEnabled(true);

			//add map marker
			Marker savedLocMarker = mMapS.addMarker(new MarkerOptions()
			.position(mySavedLoc)
			.title(nameLoc)
			.snippet(geoDisplay));

			savedLocMarker.showInfoWindow();

			//zoom to current location
			mMapS.moveCamera(CameraUpdateFactory.newLatLngZoom(mySavedLoc, 19.0f));


		}
	}





	public void updateCameraforCompassBearing(float bearing) {



		CameraPosition camPos = new CameraPosition.Builder()
		.target(myCurrentLatLng)
		.bearing(bearing)
		.tilt(60.0f)
		.zoom(19f)
		.build();
		mMapS.moveCamera(CameraUpdateFactory.newCameraPosition(camPos));

	}



	@Override
	public void onLocationChanged(Location location) {
		
	}



	@Override
	public void onStatusChanged(String provider, int status, Bundle extras) {
		// TODO Auto-generated method stub

	}



	@Override
	public void onProviderEnabled(String provider) {
		// TODO Auto-generated method stub

	}



	@Override
	public void onProviderDisabled(String provider) {
		// TODO Auto-generated method stub

	}





	@Override
	public void onSensorChanged(SensorEvent event) {
		// TODO Auto-generated method stub
		float [] gravity;
		float [] compassGeoMag;
		
		if((event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) && (event.sensor.getType() == Sensor.TYPE_MAGNETIC_FIELD)){
			gravity = event.values;
			compassGeoMag = event.values;
		}
		
		float R[] = new float[9];
		float I[] = new float[9];
		float orientation[] = new float[3];
		SensorManager.getRotationMatrix(R, I, gravity, compassGeoMag));
		SensorManager.getOrientation(R, orientation);
		
		

	}





	@Override
	public void onAccuracyChanged(Sensor sensor, int accuracy) {
		// TODO Auto-generated method stub

	}

	@Override
	  protected void onDestroy() {
	    super.onDestroy();
	    if (sensorMngr != null) {
	      sensorMngr.unregisterListener(this);
	    }
	  }





}
